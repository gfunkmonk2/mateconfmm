// Generated by gtkmmproc -- DO NOT MODIFY!


#include <mateconfmm/schema.h>
#include <mateconfmm/private/schema_p.h>

/* This file intentionally left blank */

namespace
{
} // anonymous namespace


namespace Glib
{

Mate::Conf::Schema wrap(MateConfSchema* object, bool take_copy /* = false */)
{
  return Mate::Conf::Schema(object, take_copy);
}

} // namespace Glib


namespace Mate
{

namespace Conf
{


Schema::Schema()
:
  gobject_ (mateconf_schema_new())
{}

Schema::Schema(const Schema& src)
:
  gobject_ ((src.gobject_) ? mateconf_schema_copy(src.gobject_) : 0)
{}

Schema::Schema(MateConfSchema* castitem, bool make_a_copy /* = false */)
{
  if(!make_a_copy)
  {
    // It was given to us by a function which has already made a copy for us to keep.
    gobject_ = castitem;
  }
  else
  {
    // We are probably getting it via direct access to a struct,
    // so we can not just take it - we have to take a copy of it.
    if(castitem)
      gobject_ = mateconf_schema_copy(castitem);
    else
      gobject_ = 0;
  }
}

Schema& Schema::operator=(const Schema& src)
{
  MateConfSchema *const new_gobject = (src.gobject_) ? mateconf_schema_copy(src.gobject_) : 0;

  if(gobject_)
    mateconf_schema_free(gobject_);

  gobject_ = new_gobject;

  return *this;
}

Schema::~Schema()
{
  if(gobject_)
    mateconf_schema_free(gobject_);
}

MateConfSchema* Schema::gobj_copy() const
{
  return mateconf_schema_copy(gobject_);
}


void Schema::set_type(ValueType type)
{
mateconf_schema_set_type(gobj(), ((MateConfValueType)(type))); 
}

void Schema::set_list_type(ValueType type)
{
mateconf_schema_set_list_type(gobj(), ((MateConfValueType)(type))); 
}

void Schema::set_car_type(ValueType type)
{
mateconf_schema_set_car_type(gobj(), ((MateConfValueType)(type))); 
}

void Schema::set_cdr_type(ValueType type)
{
mateconf_schema_set_cdr_type(gobj(), ((MateConfValueType)(type))); 
}

void Schema::set_locale(const std::string& locale)
{
mateconf_schema_set_locale(gobj(), locale.c_str()); 
}

void Schema::set_short_desc(const Glib::ustring& desc)
{
mateconf_schema_set_short_desc(gobj(), desc.c_str()); 
}

void Schema::set_long_desc(const Glib::ustring& desc)
{
mateconf_schema_set_long_desc(gobj(), desc.c_str()); 
}

void Schema::set_owner(const Glib::ustring& owner)
{
mateconf_schema_set_owner(gobj(), owner.c_str()); 
}

void Schema::set_default_value(const Value& value)
{
mateconf_schema_set_default_value(gobj(), (value).gobj()); 
}

ValueType Schema::get_type() const
{
  return ((ValueType)(mateconf_schema_get_type(const_cast<MateConfSchema*>(gobj()))));
}

ValueType Schema::get_list_type() const
{
  return ((ValueType)(mateconf_schema_get_list_type(const_cast<MateConfSchema*>(gobj()))));
}

ValueType Schema::get_car_type() const
{
  return ((ValueType)(mateconf_schema_get_car_type(const_cast<MateConfSchema*>(gobj()))));
}

ValueType Schema::get_cdr_type() const
{
  return ((ValueType)(mateconf_schema_get_cdr_type(const_cast<MateConfSchema*>(gobj()))));
}

std::string Schema::get_locale() const
{
  return Glib::convert_const_gchar_ptr_to_stdstring(mateconf_schema_get_locale(const_cast<MateConfSchema*>(gobj())));
}

Glib::ustring Schema::get_short_desc() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(mateconf_schema_get_short_desc(const_cast<MateConfSchema*>(gobj())));
}

Glib::ustring Schema::get_long_desc() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(mateconf_schema_get_long_desc(const_cast<MateConfSchema*>(gobj())));
}

Glib::ustring Schema::get_owner() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(mateconf_schema_get_owner(const_cast<MateConfSchema*>(gobj())));
}

Value Schema::get_default_value() const
{
  return Value(mateconf_schema_get_default_value(const_cast<MateConfSchema*>(gobj())));
}


} // namespace Conf

} // namespace Mate
