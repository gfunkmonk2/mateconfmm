// Generated by gtkmmproc -- DO NOT MODIFY!


#include <mateconfmm/value.h>
#include <mateconfmm/private/value_p.h>

// -*- Mode: C++; c-basic-offset: 4  -*-
/* $Id: value.ccg,v 1.2 2005/01/11 12:08:16 murrayc Exp $ */

/* value.hg
 * 
 * Copyright (C) 2000-2002 MateConfmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <mateconf/mateconf.h>
#include "mateconfmm/schema.h"

namespace
{

//gmmproc guesses the mateconf prefix wrongly, so we help it:
inline static GType g_conf_value_type_get_type()
{
  return mateconf_value_type_get_type();
}

inline static GType g_conf_unset_flags_get_type()
{
  return mateconf_unset_flags_get_type();
}

} //anonymous namespace

namespace Mate
{

namespace Conf
{

void ValueTraits::release_c_type(MateConfValue* ptr)
{
  mateconf_value_free(ptr);
}
  

MateConfValue* ValueSchemaTraits::to_c_type(const Schema& ptr)
{
  MateConfValue* v = mateconf_value_new(MATECONF_VALUE_SCHEMA);
  mateconf_value_set_schema(v, ptr.gobj());
  return v;
}

Schema ValueSchemaTraits::to_cpp_type(MateConfValue* ptr)
{
  return Schema(mateconf_value_get_schema(ptr), true);
}

MateConfValue* ValueStringTraits::to_c_type(const Glib::ustring& ptr)
{
  MateConfValue* v = mateconf_value_new(MATECONF_VALUE_STRING);
  mateconf_value_set_string(v,ptr.c_str());
  return v;
}

Glib::ustring ValueStringTraits::to_cpp_type(MateConfValue* ptr)
{
  return Glib::ustring(mateconf_value_get_string(ptr));
}

MateConfValue* ValueIntTraits::to_c_type(const int& ptr)
{
  MateConfValue* v = mateconf_value_new(MATECONF_VALUE_INT);
  mateconf_value_set_int(v,ptr);
  return v;
}

int ValueIntTraits::to_cpp_type(MateConfValue* ptr)
{
  return mateconf_value_get_int(ptr);
}

MateConfValue* ValueBoolTraits::to_c_type(const bool& ptr)
{
  MateConfValue* v = mateconf_value_new(MATECONF_VALUE_BOOL);
  mateconf_value_set_bool(v, ptr);
  return v;
}

bool ValueBoolTraits::to_cpp_type(MateConfValue* ptr)
{
  return (bool)mateconf_value_get_bool(ptr);
}

MateConfValue* ValueFloatTraits::to_c_type(const double& ptr)
{
  MateConfValue* v = mateconf_value_new(MATECONF_VALUE_FLOAT);
  mateconf_value_set_float(v,ptr);
  return v;
}

double ValueFloatTraits::to_cpp_type(MateConfValue* ptr)
{
  return mateconf_value_get_float(ptr);
}


Value::Value(ValueType type)
  : gobject_(0)
{
  if(type != VALUE_INVALID)
    gobject_ = mateconf_value_new((MateConfValueType)type);
}

ValueType Value::get_type() const 
{
  if(gobject_ == 0)
    return VALUE_INVALID;

  return (ValueType)gobj()->type;
}

Value Value::get_car() const
{
  return Value(mateconf_value_get_car(gobj()), true);
}

Value Value::get_cdr() const
{
  return Value(mateconf_value_get_cdr(gobj()), true);
}

Schema Value::get_schema() const
{
  return Schema(mateconf_value_get_schema(gobj()), true);
}

} /* namespace Conf */
} /* namespace Mate */

namespace
{
} // anonymous namespace

// static
GType Glib::Value<Mate::Conf::ValueType>::value_type()
{
  return g_conf_value_type_get_type();
}

// static
GType Glib::Value<Mate::Conf::UnsetFlags>::value_type()
{
  return g_conf_unset_flags_get_type();
}


namespace Glib
{

Mate::Conf::Value wrap(MateConfValue* object, bool take_copy /* = false */)
{
  return Mate::Conf::Value(object, take_copy);
}

} // namespace Glib


namespace Mate
{

namespace Conf
{


Value::Value(const Value& src)
:
  gobject_ ((src.gobject_) ? mateconf_value_copy(src.gobject_) : 0)
{}

Value::Value(MateConfValue* castitem, bool make_a_copy /* = false */)
{
  if(!make_a_copy)
  {
    // It was given to us by a function which has already made a copy for us to keep.
    gobject_ = castitem;
  }
  else
  {
    // We are probably getting it via direct access to a struct,
    // so we can not just take it - we have to take a copy of it.
    if(castitem)
      gobject_ = mateconf_value_copy(castitem);
    else
      gobject_ = 0;
  }
}

Value& Value::operator=(const Value& src)
{
  MateConfValue *const new_gobject = (src.gobject_) ? mateconf_value_copy(src.gobject_) : 0;

  if(gobject_)
    mateconf_value_free(gobject_);

  gobject_ = new_gobject;

  return *this;
}

Value::~Value()
{
  if(gobject_)
    mateconf_value_free(gobject_);
}

MateConfValue* Value::gobj_copy() const
{
  return mateconf_value_copy(gobject_);
}


void Value::set(gint val)
{
mateconf_value_set_int(gobj(), val); 
}

void Value::set(gdouble val)
{
mateconf_value_set_float(gobj(), val); 
}

void Value::set(bool val)
{
mateconf_value_set_bool(gobj(), static_cast<int>(val)); 
}

void Value::set(const Schema& sc)
{
mateconf_value_set_schema(gobj(), (sc).gobj()); 
}

void Value::set_car(const Value& car)
{
mateconf_value_set_car(gobj(), (car).gobj()); 
}

void Value::set_cdr(const Value& cdr)
{
mateconf_value_set_cdr(gobj(), (cdr).gobj()); 
}

void Value::set(const Glib::ustring& val)
{
mateconf_value_set_string(gobj(), val.c_str()); 
}

void Value::set_list_type(ValueType type)
{
mateconf_value_set_list_type(gobj(), ((MateConfValueType)(type))); 
}

void Value::set_int_list(const SListHandle_ValueInt& list)
{
mateconf_value_set_list_nocopy(gobj(), list.data()); 
}

void Value::set_bool_list(const SListHandle_ValueBool& list)
{
mateconf_value_set_list_nocopy(gobj(), list.data()); 
}

void Value::set_float_list(const SListHandle_ValueFloat& list)
{
mateconf_value_set_list_nocopy(gobj(), list.data()); 
}

void Value::set_string_list(const SListHandle_ValueString& list)
{
mateconf_value_set_list_nocopy(gobj(), list.data()); 
}

void Value::set_schema_list(const SListHandle_ValueSchema& list)
{
mateconf_value_set_list_nocopy(gobj(), list.data()); 
}

ValueType Value::get_list_type() const
{
  return ((ValueType)(mateconf_value_get_list_type(const_cast<MateConfValue*>(gobj()))));
}

int Value::get_int() const
{
  return mateconf_value_get_int(const_cast<MateConfValue*>(gobj()));
}

bool Value::get_bool() const
{
  return mateconf_value_get_bool(const_cast<MateConfValue*>(gobj()));
}

double Value::get_float() const
{
  return mateconf_value_get_float(const_cast<MateConfValue*>(gobj()));
}

Glib::ustring Value::get_string() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(mateconf_value_get_string(const_cast<MateConfValue*>(gobj())));
}

SListHandle_ValueFloat Value::get_float_list() const
{
  return SListHandle_ValueFloat(mateconf_value_get_list(const_cast<MateConfValue*>(gobj())), Glib::OWNERSHIP_NONE);
}

SListHandle_ValueInt Value::get_int_list() const
{
  return SListHandle_ValueInt(mateconf_value_get_list(const_cast<MateConfValue*>(gobj())), Glib::OWNERSHIP_NONE);
}

SListHandle_ValueBool Value::get_bool_list() const
{
  return SListHandle_ValueBool(mateconf_value_get_list(const_cast<MateConfValue*>(gobj())), Glib::OWNERSHIP_NONE);
}

SListHandle_ValueString Value::get_string_list() const
{
  return SListHandle_ValueString(mateconf_value_get_list(const_cast<MateConfValue*>(gobj())), Glib::OWNERSHIP_NONE);
}

SListHandle_ValueSchema Value::get_schema_list() const
{
  return SListHandle_ValueSchema(mateconf_value_get_list(const_cast<MateConfValue*>(gobj())), Glib::OWNERSHIP_NONE);
}

Glib::ustring Value::to_string() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(mateconf_value_to_string(const_cast<MateConfValue*>(gobj())));
}


} // namespace Conf

} // namespace Mate
